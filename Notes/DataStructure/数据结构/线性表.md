- 线性结构
  - 顺序表（线性表基础）
  - 链表（线性表基础）
  - 栈（特殊线性表）
  - 队列（特殊线性表）
  - 字符串（特殊线性表）
  - 数组（线性表的拓展）
  - 广义表（线性表的拓展）
- 非线性结构
  - 树
  - 图
  - 哈希表（数组+链表）

根据前驱（predecessor）和后继（successor）的关系划分数据结构：

- 线性表：一对一，一个前驱，一个后继。
- 树：一对多，一个前驱，多个后继。
- 图：多对多，图中的顶点存在多个前驱，多个后继。

- 集合：除同在一个集合中无其他关系。

## 线性表

线性表（Linear List）是具有相同特性的数据元素组成的一个有限序列。

在计算机中，线性表有两种基本的存储结构：顺序存储结构和链式存储结构。

顺序存储结构：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构，对应**顺序表**。

链式存储结构：结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻，对应**链表**。

### 1. 顺序表

线性表顺序存储结构占用了一片连续的存储空间，知道某个元素的存储位置就可以计算其他元素的存储位置。

元素的数据类型必须相同，元素的存放地址连续，也称为顺序表，而顺序表的表长则是可变的（比如删除元素）。

- 元素存取方法：随机存取，时间复杂度为 $O(1)$

  在访问顺序表时，可以快速计算出任何一个数据元素的内存地址，因此可以粗略地认为，访问每个元素所花费的时间相等。（根据首个元素的地址，以及访问元素与首个元素的间隔，可以计算得到访问元素的地址，等差数列中求某一项的值。）这种读取数据元素的方法称为**随机存取法**。

- 优点：可以随机读取顺序表中任意一个元素。
- 缺点：属于静态存储形式，数据元素的个数不能自由扩充；插入删除时需要移动大量元素。
- 插入和删除操作：时间复杂度 $O(n)$
- 适用情况
  - 表长变化不大，且能事先确定表长的变化范围
  - 很少进行插入和删除操作，经常进行按元素位置序号访问数据元素

### 2. 链表

链表使用一组物理位置任意的存储单元来存放线性表的数据元素。

- **头指针**

  单链表由头指针唯一确定，因此单链表可以用头指针的名字来命名。链表是一定要有头指针的。

- **数据域和指针域**

  链表中各个结点包含两个部分，即**数据域和指针域**。其中数据域存储元素数值数据，指针域存储后继结点的存储位置地址。

- **头结点**

  链表可以带头结点，如下图的情况所示；也可以不带头结点，此时头指针直接指向首元结点。

  ![指针](D:\Typora\Notes\DataStructure\数据结构\指针.png)



- 元素存取方法：访问元素时只能通过头指针进入链表，并通过每个节点的指针域依次向后顺序访问后续节点，这种访问元素的方法称为**顺序读取法**。

- 链表重要操作：[代码实现](https://www.programiz.com/dsa/linked-list-operations)

  - 遍历
  - 插入：头插法、尾插法、中间插法，时间复杂度为 $O(1)$
  - 删除：删除头、删除尾、删除中间，时间复杂度为 $O(n)$
  - 查找：时间复杂度为 $O(n)$
  - 排序
  - 构建
    - 头插法：元素插入在链表头部，也叫前插法。
    - 尾插法：元素插入在链表尾部，也叫后插法。

- 适用情况：

  - 长度变化较大
  - 频繁进行插入和删除操作

- 代码实现：

  ```python
  class Node:
      def __init__(self, data):
          self.data = data
          self.next = None
  
      def __repr__(self):
          return self.data
  
  class LinkedList:
      def __init__(self):
          self.head = None
  
      def __repr__(self):
          node = self.head
          nodes = []
          while node is not None:
              nodes.append(node.data)
              node = node.next
          nodes.append("None")
          return " -> ".join(nodes)
  ```

  

- 链表类型：单向链表、双向链表、循环链表。

![链表类型](D:\Typora\Notes\DataStructure\数据结构\链表类型.png)

#### 2.1 单向链表

- 定义

  每个结点只有一个指针域（指向后继）的链表称为单链表，单链表由头指针唯一确定。

#### 2.2 双向链表

- 定义

  每个结点有两个指针域（一个指向前驱，一个指向后继）的链表称为双向链表。

- 类型

  - 双向循环链表：头结点的前驱指针指向链表的最后一个结点，让最后一个结点的后继指针指向头结点。

- 优点

  克服了单向链表找后继结点方便，找前驱结点困难的问题（解决了单链表无法逆向索引的问题）

#### 2.3 循环链表

- 定义

  首尾相接的链表称为循环链表（链表中最后一个结点的指针域指向头结点，整个链表形成一个环。）。

- 类型

  - 头指针表示单向循环链表：头指针指向头结点，即一般情况。
  - 尾指针表示单向循环链表：头指针指向最后一个结点，而最后一个结点指向头结点（非首元节点）。
  - 单向循环链表
  - 双向循环链表

- 优点

  从链表中的任一结点出发都可以找到链表中其他结点。

**链表比较**

- 单向链表：存储了头指针的地址，
  - 查找链表的第一个元素的时间复杂度是O(1)
  - 查找链表最后一个元素的时间复杂度是O(n)
- 循环链表：存储的是尾指针的地址，
  - 查找链表的第一个元素的时间复杂度都是O(1)
  - 查找链表的最后一个元素的时间复杂度是O(1)

### 3. 栈

栈(stack)：也称为堆栈，是一种限定只能在表的一端进行插入和删除操作的**线性表**。通常只能在表尾插入元素，也只能在表尾删除元素。我们把栈中允许插入和删除的一端称为**栈顶**（Top），另一端称为**栈底**（Base or Bottom）。当表中没有任何数据元素时，称为**空栈**。

![栈基础](D:\Typora\Notes\DataStructure\数据结构\栈基础.png)

- 进出顺序：后进先出，Last In First Out
- 栈基本操作
  - **插入操作**：称为**入栈**或进栈（压入，push）：插入一个元素到栈顶（表尾）的操作称为入栈。
  - **删除操作**：称为**出栈**或退栈（弹出，pop）：从栈顶（表尾）删除一个元素的操作称为出栈。
- 栈类型：**顺序栈**、**链栈**
- 空栈和满栈：使用数组作为顺序栈存储方式的特点是简单方便，但容易产生**溢出**（数组大小固定）
  - 上溢（overflow）：栈已经满了，又要压入元素。存元素要判断栈是否已满。
  - 下溢（underflow）：栈已经空了，还要弹出元素。取元素要判断栈是否已空。
- 关系：**操作受限的线性表，限定只能在表尾插入元素，也只能在表尾删除元素。**

### 4. 队列

队列(queue):只能在表尾插入元素，而只能在表头删除元素。

- 进出顺序：先进先出，First In First Out 
- 在表尾端（右侧，队尾Rear）插入，在表头端（左侧，队头Front）删除的线性表。
- 队列操作

  - 入队：尾部插入元素
  - 出队：头部删除元素
- 队列类型：顺序对列、链队列，以循环顺序队列更为常见。
- 关系：**操作受限的线性表，只能在表尾插入元素，而只能在表头删除元素。**

#### 4.1 普通队列

首先在创建[普通队列](https://www.programiz.com/dsa/queue)时需要指定队列可以存放的最大元素个数 $\rm capacity$ ，并设置队列初始化时 $\rm rear=-1,front=-1$，操作队列时指针情况变化如下：

- 元素入队（enqueue）： $\rm rear = rear +1$，指针指向下一个可以入队的位置
- 元素出队（dequeue）：$\rm front = front + 1$，指针指向下一个等待出队的位置
- 真溢出：$\rm rear=capacity , front =-1$ 
- 假溢出：$\rm rear=capacity , front \ge 0$ ，当 $\rm front=0$ 时，表示第一个位置是空闲的。
- 当 $\rm rear=front$ 时，可能是队列满了，也可能是队列空了。
  - 解决方案1：另外设置一个标志以区别队空、队满
    - 当$\rm (rear+1)\% capacity=front$ 时，队满
    - 当$\rm front=-1$ 时，队空
      - 添加元素入队时，初始时$\rm front=-1$ ，此时为队空，当队未满而有元素入队时，$\rm front \in [0,capacity-1]$，可见在此过程中不会取 $-1$。
      - 删除元素出队时，若此时$\rm front=-1$ ，此时为队空，表示队列中没有元素。
      - 在$\rm front=rear\in [0,capacity-1]$ 时 表示队列中只有一个元素，删除该元素后，需要重置 $\rm front=-1,rear=-1$ ，此时就会变为空对列。 
  - 解决方案2：另外设置一个变量，记录元素个数
  - 解决方案3：少用一个元素，如分配了6个空间，只使用5个空间
    - 当$\rm (rear+1)\% capacity=front$ 时，队满
    - 当 $\rm rear=front$ 时，队空

#### 4.2 循环队列

循环队列（Circular Queue）进行入队（enqueue）和出队（dequeue）的情形如下：

<img src="D:\Typora\Notes\DataStructure\数据结构\circular-queue-program.webp" alt="circular-queue-program" style="zoom: 33%;" />

循环队列可以解决普通队列存在的**假上溢**问题。假上溢问题产生的情形为：如上图中所示，当普通队列在入队$1,2,3,4,5$和出队$1,2$之后，此时队头的前2个位置空出来了，而后边的三个元素并不会自动移动过来，此时在队尾添加元素入队时，就会产生溢出。然而队列中仍然有空闲位置，这种情况就是**假溢出**。解决该问题的办法就是使用**循环队列**，如果 $\rm (rear + 1) \%\ capacity  =front$ 等式成立，则表示队列已满，否则表示队列中仍有空闲位置可以添加元素，新元素存放位置由 $\rm (rear + 1) \%\ capacity$ 来确定，比如在添加 $6$ 时，，而 $\rm (rear + 1) \%\ capacity = (4+1)\%\ 5 = 0$，可知其存放在第一个位置，而在添加 $7$ 时， $\rm (rear + 1) \%\ capacity = (0+1)\%\ 5 = 1$，可知其存放在第二个位置。

- 满队列：$\rm (rear + 1) \%\ capacity  =front$ 
- 空对列：$\rm front=-1$ 

循环队列可以解决队列假上溢的问题。假上溢的问题就是假如队列中存储了6个元素，现在执行出队3次之后，队头的前3个位置空出来了，后边的3个元素并不会自动移动过来，此时在队尾添加元素入队时，就会生成溢出，然而队列中仍然有空闲位置，这种情况就是假上溢的问题，解决该问题的办法就是使用循环队列。具体操作是队列尾部没办法添加了，通过判断rear指针的位置等于队列的最大元素个数判断出再添加元素就会产生溢出，然后进行取余运算，6%6=0，在队头添加元素，7%6=1，在第二个位置添加元素，变成好似循环队列一般。

#### 4.3 双端队列

双端队列中元素的插入和删除可以从队前（Front）或队后（Rear）执行。因此，它不遵循FIFO规则(先进先出)。

#### 4.4 优先级队列

**优先级队列（Priority Queue）可以使用数组、链表、二叉堆、二叉查找树来实现。**在这些数据结构中，堆数据结构可以提供一个优先级队列的高效实现。优先级队列使用不同数据结构实现的对比分析：

| Operations         | peek   | insert     | delete     |
| :----------------- | :----- | :--------- | :--------- |
| Linked List        | `O(1)` | `O(n)`     | `O(1)`     |
| Binary Heap        | `O(1)` | `O(log n)` | `O(log n)` |
| Binary Search Tree | `O(1)` | `O(log n)` | `O(log n)` |

- 普通队列删除元素：先进先出原则
- 优先级队列删除元素：删除优先级最高的元素

### 5. 字符串

- 定义：零个或多个任意字符组成的有限序列。
- 子串：串中任意个连续字符组成的子序列（含空串）称为该串的子串，包含子串的串称为**主串**，**真子串**是指不包含自身的所有子串。
- 串类型：**顺序串**、**链串**
- 模式匹配（字符串匹配）算法
  - BF算法
  - KMP算法
- 关系：**内容受限的线性表**

### 6. 数组

- 定义：按照一定格式排列起来的具有**相同数据类型**的数据元素的**集合**。一般使用顺序存储结构来表示数组（array）。
- 多维数组
  - 一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组，是一个定长的线性表。
  - 二维数组：若一维数组中的数据元素又是一个一维数组结构，则称为二维数组。两种存储方式：以行序为主序和以列序为主序。
  - 三维数组：若二维数组中的数据元素又是一个一维数组结构，则称为三维数组。
  - n 维数组：若 n-1 维数组中的数据元素又是一个一维数组结构，则称为 n 维数组。
- 关系：**线性表结构是数组结构的一个特例，而数组结构又是线性表结构的拓展。**

#### 6.1 静态数组

静态数组（static array）：Static array is an array for which the size or length is determined when the array is created and/or allocated.

数组长度在创建或分配时必须提前指定，而不能在运行时改变数组的大小。

#### 6.2 动态数组

动态数组（dynamic array）：Dynamic arrays allow us to specify the size of an array at run-time. 

动态数组允许在运行时根据需要动态添加和删除元素，数组长度也可以随时改变。

### 7. 广义表

- 定义：广义表（List）是由零个或多个元素组成的有限序列，序列中每个元素的数据类型可以不同，每一个元素可以是原子，也可以是广义表。

- 表头：第一个元素，该元素可以是原子，也可以是子表（广义表）

- 表尾：不是表的最后一个元素，而是除表头外的其他元素构成的子表（广义表）
- 关系：**广义表可以看做是线性表的推广，线性表可以看作是广义表的特例。**






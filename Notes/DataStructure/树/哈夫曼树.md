## 哈夫曼树

- 哈夫曼树(Huffman Tree)，也称为最优二叉树

  - **路径**：从树中一个节点到另一个节点所经过的边构成两个节点之间的路径。

  - **路径长度**：两个节点路径上的边数。

  - **树的路径长度**：从树的根节点到每一个节点的路径长度之和。

    节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树，但是路径长度最短的二叉树未必是完全二叉树。

  - **权值**：给树中节点赋予一个有着某种含义的数值，则这个值称为该节点的权值。

  - **节点的带权路径长度**：从**根节点**到该节点的路径长度与该节点的权值的乘积。

  - **树的带权路径长度**：树中所有**叶节点**的带权路径长度之和。(Weighted Path Length)
    $$
    WPL = \sum_{k=1}^nw_kl_k
    $$
    

    **哈夫曼树是（树的）带权路径长度最短的树。**带权路径长度最短的比较前提是树的度要相同，即同为二叉树、三叉树进行比较。**最优二叉树**是指带权路径长度最短的二叉树。

  - **哈夫曼算法**

    1. 根据 n 个给定的权值构造 n 棵二叉树，构成一个森林，每棵二叉树只有一个带权值的根节点。
    2. 在 n 棵二叉树中选取两棵根节点权值最小的树作为左右子树，生成一颗新的二叉树，且设置新生成的二叉树的根节点的权值为其左右子树根节点的权值之和。
    3. 在森林中删除上一步选中的两棵树，同时将新生成的二叉树加入到森林中。
    4. 重复步骤2和3，直至森林中只剩下一棵树为止，这棵树即为哈夫曼树。

  - **哈夫曼树的性质**

    - 哈夫曼树中未必是满二叉树，权值越大的叶节点离根节点越近，具有相同带权节点的哈夫曼树不唯一。

    - 哈夫曼树中节点的度只能为0或2，而不可能为1。

    - 包含n 个节点的哈夫曼树，两两合并产生一个新节点，若存在n个叶节点，则共需要合并n-1次，且每次合并都会产生一个新的节点，因此哈夫曼树中最终会有 2n - 1个节点。度为2个节点共有 n-1 个，度为0的节点（叶节点）共有n个。

  - **哈夫曼树构造的算法实现**

  - **哈夫曼编码**

    - **前缀编码**:在一个编码方案中，任何一个编码都不是其他编码的前缀，则称编码为前缀编码。

    - **前缀和后缀**：For instance, the prefixes of the string `"abcd"` are `["a","ab","abc"]`. The suffixes are `["bcd", "cd", "d"]`.

    - 每个字符使用等长的二进制编码表示，并按照给定的二进制编码长度进行解码，得到最初的字符表示。定长的编码方式比较浪费空间。若将编码设计为**长度不等**的二进制编码，并让**字符串中出现次数较多的字符使用尽可能短的编码**（使得字符串的二进制编码表示长度变短），则由字符串转换得到的二进制表示所占用的内存空间就会减少。 

    - 任何一个字符的二进制编码表示都不能是另一个字符二进制编码表示的前缀，否则就会出现重码的问题，在解码的时候就会出现歧义，无法恢复到最初的字符串。

      

- 


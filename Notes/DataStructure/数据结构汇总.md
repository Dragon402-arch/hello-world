## 常用数据结构与算法

- 图示

  ![image-20211207173905036](C:\Users\千江映月\AppData\Roaming\Typora\typora-user-images\image-20211207173905036.png)

  
  
  线性表概念：链表、数组、动态数组、广义表、栈、队列

- **线性表：线性表的表长是可以变化的。**

  - **链表：线性表的链式存储结构**

    - 单向链表：每个节点只有一个指针域（指向后继）的链表称为单链表。
    - 双向链表：每个节点有两个指针域（一个指向前驱，一个指向后继）的链表称为双向链表。
    - 循环链表：首尾相接的链表称为循环链表。
      - 头指针循环链表
      - 尾指针循环链表
    - 链表比较：
      - 单向链表：存储了头指针的地址，
        - 查找链表的第一个元素的时间复杂度是O(1)
        - 查找链表最后一个元素的时间复杂度是O(n)

      - 循环链表：存储的是尾指针的地址，
        - 查找链表的第一个元素的时间复杂度都是O(1)
        - 查找链表的最后一个元素的时间复杂度是O(1)


    访问元素时只能通过头指针进入链表，并通过每个节点的指针域依次向后顺序访问后续节点，这种访问元素的方法称为**顺序读取法**。

  - **顺序表:线性表的顺序存储结构**

    - 数组：数组长度不可动态定义（C语言中），元素的数据类型必须相同。

      - 维度

        - 一维数组：包含指定元素个数的数组
        - 多维数组
      - 在访问顺序表时，可以快速计算出任何一个数据元素的内存地址，因此可以粗略地认为，访问每个元素所花费的时间相等。（根据首个元素的地址，以及访问元素与首个元素的间隔，可以计算得到访问元素的地址，等差数列中求某一项的值。）这种读取数据元素的方法称为**随机读取法**。
      - 优点：可以随机读取顺序表中任意一个元素。
      - 缺点：属于静态存储形式，数据元素的个数不能自由扩充；插入删除时需要移动大量元素。

    - 动态数组：数组长度可以动态定义

    - 广义表（List）：元素的数据类型可以不同，其中每一个元素可以是原子，也可以是广义表

      - 表头：第一个元素，该元素可以是原子，也可以是子表（广义表）

      - 表尾：不是表的最后一个元素，而是除表头外的其他元素构成的表

        广义表可以看做是线性表的推广，线性表可以看作是广义表的特例。

  - **栈和队列：限定插入和删除操作只能在表的端点进行的线性表。**

    - 栈(stack)：只能在表尾插入元素，也只能在表尾删除元素。

      - 后进先出，Last In First Out
      - 表尾称为栈顶（TOP），表头称为栈底（Base）
      - 入栈：插入一个元素到栈顶（表尾）的操作称为入栈。压入（Push）
      - 出栈：从栈顶（表尾）删除一个元素的操作称为出栈。弹出（Pop）
      - 顺序栈、链栈
      - 使用数组作为顺序栈存储方式的特点是简单方便，但容易产生**溢出**（数组大小固定）
        - 上溢（overflow）：栈已经满了，又要压入元素。存元素要判断栈是否已满。
        - 下溢（underflow）：栈已经空了，还要弹出元素。取元素要判断栈是否已满。

    - 队列(queue):只能在表尾插入元素，而只能在表头删除元素。

      - 先进先出，First In First Out

      - 在表尾端（右侧，队尾Rear）插入，在表头端（左侧，队头Front）删除的线性表。

      - 入队：插入元素

      - 出队：删除元素

      - 顺序对列、链队列，以循环顺序队列更为常见。

      - 在入队和出队时会使用rear和front双指针执行添加和删除元素的操作，但是会存在假溢出的问题，因此需要使用循环队列，也就是将分配给队列的空间循环使用。但是还会存在队列满了和空了时，rear和front指针都相等的情况，此时无法判断是满了还是空了，因此会采用少用一个元素空间的方法（如分配了6个空间，只使用5个空间）从而在rear和front指针是相等时可以判断出队列是空的，而在rear和front指针 若满足（rear + 1 )%max_queue_size = front ，则可以判断出队列是满了。

        当rear等于 max_queue_size时就会产生溢出，而若此时front=0，则再入队元素就会**真溢出**；若此时rear不为0，队列仍有剩余空间，但是再入队元素也会产生溢出，此时的情况称为**假溢出**。若此时队列的开始端可以判断出是空的，则可以从头开始使用空着的存储空间。若rear + 1 = max_queue_size。

        rear =（rear + 1 )%max_queue_size，【如rear=5（索引从0开始，第6个元素）,5+1=6，6%6=0，rear=0】，对于front也是同样的道理（rear对应添加入队，front对应于删除出队）

      - 计算队列中元素个数：(rear - front + max_queue_size )%max_queue_size

      - 循环队列：解决假上溢的问题。假上溢的问题就是假如队列中存储了6个元素，现在执行出队三次之后，队头的前三个位置空出来了，后边的三个元素并不会自动移动过来，此时在队尾添加元素入队时，就会生成溢出，然而队列中仍然有空闲位置，这种情况就是假上溢的问题，解决该问题的办法就是使用循环队列，也就是队列尾部没办法添加了，通过判断rear指针的位置等于队列得长度判断出再添加元素就会产生溢出，然后进行取余运算，6%6=0，在队头添加元素，7%6=1，在第二个位置添加元素，变成好似循环队列一般。

        将队列空间想象成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear指针为max_queue_size时，若队列的开始端空着，又可以从头使用空着的空间。当front指针为max_queue_size时，也是一样。

  - 查找

    - 顺序查找（顺序表、链表皆可以），时间复杂度为O(n)

    - 二分查找（要求有序，顺序表可以，链表不可以）,时间复杂度为O（logn）

    - 分块查找（索引顺序表的查找）

      - 将表中元素分成几块，要求表内元素有序，或是要求块间有序，块内元素可以无序。

        若 i < j，则第 j 块所有记录的关键字均大于第 i 块中的最大关键字，

      - 建立索引表（每个节点含有最大关键字域和指向本块第一个节点的指针，且按关键字有序。）

      - 查找过程：先确定待查记录所在块，再在块内查找。

      - 适用情况：既要求快速查找，又要满足经常插入和删除。二分查找和顺序查找在找到元素之后，若要进行插入和删除操作需要移动大量元素。

    - 二叉搜索树的性质：按照中序遍历非空的二叉搜索树可以得到一个递增有序的序列。

  - 散列表（哈希表 Hash Table）

    - 散列方法：选取某个函数，使用该函数按照关键字key计算元素的存储地址，并按照此地址进行存放。
    - 散列函数（哈希函数）：散列方法中使用的转换函数。
    - 散列表：按照上述方法构造的表就是散列表。
    - 哈希碰撞（hash collision 冲突）：不同的关键字被映射到同一个散列地址。
    - 同义词：具有相同哈希值的多个关键字key。
    - 散列函数的构造方法：
      - 直接定址法：kx+b 其中x就是key值，使用线性函数值作为散列地址，不会产生冲突。
      - 数字分析法
      - 平方取中法
      - 折叠法
      - 除留余数法
      - 随机数法
    - 散列表查找是使用空间换时间，但是仍希望散列的地址空间尽量小。
    - 哈希函数映射得到的哈希值可以均匀分布，以减少冲突。
    - 处理哈希碰撞的方法：
      - 开放寻址法
        - 线性探测法（linear probing）：取余发生冲突时，将余数加1，如果还是冲突，加2，
        - 二次探测法： +1，-1，+4，-4，+9，-9，……，q^2
        - 伪随机探测法: 加上一个伪随机数
        - 该方法使得非同义词也会产生寻址冲突，即就近存放的和直接寻址过来的有冲突。
      - 拉链法（separate chaining）：相同哈希值的key组成一个单向链表，当链表长度超过一定长度时转换为红黑树。
    - 时间换空间的做法就是使用非常大的空间，使得哈希值都不会出现哈希碰撞，此时进行查找操作都是O(1)的时间复杂度。

    































- ![image-20211212185908364](C:\Users\千江映月\AppData\Roaming\Typora\typora-user-images\image-20211212185908364.png)

- 森林：m（m>=0）棵互不相交的树的集合。

  删除根节点之后，一棵树就变成了一个森林，一棵树也可以看成是一个特殊的森林。

  给森林中的各个子树添加一个共同的父节点，一个森林就变成了一棵树。

- 树的遍历：

  - 递归
  - 循环（栈）
  - 层次遍历(队列)


- 字符串匹配

  - Brute-Force  Match
  - Rabin-Karp algorithm
    - 该算法基于这样的思想:如果两个字符串的哈希值相等，则假定这两个字符串也相等。这个算法的主要问题是，可能有两个不同的字符串，它们的哈希值相等。在这种情况下，该算法可能无法工作;这种情况被称为虚假攻击。为了避免这个问题，在确定模式和子字符串的哈希值匹配之后，我们通过逐个字符比较它们来确保模式实际上是匹配的。

  - KMP
  - BM

- 有序表的合并（使用链表实现）44


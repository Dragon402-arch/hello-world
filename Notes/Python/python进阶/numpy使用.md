#### 向量与矩阵的运算

- 一维列向量与二维列向量

  - 示例：

    ```python
    import numpy as np
    
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    ```

    

  - 一维行向量(转置)与矩阵相乘 （没有出现理想的结果）

    ```python
    print(x[1, :].T * y)
    
    
    """
    输出
    [[12 32]
     [20 48]]
    """
    
    print(x[1, :] * y)
    
    """
    输出
    [[12 32]
     [20 48]]
    """
    
    """
    运算的本意是将行向量转置为列向量后，分别与矩阵的每一列相乘，但是不论行向量是否进行转置，都还是行向量本身与矩阵的每一行相乘了。真正实现原本意思的操作为：print(x[1, :].reshape(-1, 1) * y)
    """
    ```

    

  - 一维行向量变形为二维矩阵（本质上仍是列向量）与矩阵相乘，(实现了理想的效果)

    ```python
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    
    print(x[1, :].reshape(-1, 1) * y)
    
    """输出
    [[12 16]
     [40 48]]
    """
    
    ```

    

  - 行向量转置与列向量相乘，(实现了理想的效果)

    ```python
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    
    print(x[1, :].T * y[:, 1])
    
    """
    输出
    [16 48]
    """
    ```

    

  - 矩阵与列向量转置相乘，(实现了理想的效果)

    ```python
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    
    print(x * y[:, 1].T)
    
    """
    输出
    [[ 4 12]
     [16 48]]
    """
    ```

    

  - 矩阵与行向量相乘，（实现了理想的效果）

    ```python
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    
    print(x * y[1, :])
    
    """
    输出
    [[ 5 12]
     [20 48]]
    """
    ```

- 运算表示

  - 矩阵乘法与矩阵逐元素积

    ```python
    x = np.array([[1, 2],
                  [4, 8]])
    y = np.array([[3, 4],
                  [5, 6]])
    
    # @ 表示矩阵乘法，即matrix product
    print(x@y)
    """
    输出
    [[13 16]
     [52 64]]
    """
    
    # np.dot()表示矩阵乘法
    print(np.dot(x,y))
    """
    输出
    [[13 16]
     [52 64]]
    """
    
    # * 表示逐元素积,即element-wise product
    print(x * y)
    """
    输出：
    [[ 3  8]
     [20 48]]
    """
    
    # np.multiply()表示逐元素积
    
    print(np.multiply(x,y))
    """
    输出：
    [[ 3  8]
     [20 48]]
    """
    ```

    



#### 数组切片与索引

- 索引

  - 使用索引

    ```python
    import numpy as np
    
    x = np.array([[1, 2],
                  [4, 8]])
                  
                  
    print(x[0])
    """
    输出：
    [1 2]
    """
    
    print(x[0,:])
    """
    输出：
    [1 2]
    """
    
    """如果是第一维的索引，则可以直接使用索引即可，如果不是第一维的索引，则需要使用切片，如print(x[:,0])"""
    
    print(x[:,0])
    """
    输出：
    [1 4]
    """
    
    print(x[1,0])
    """
    输出：
    4
    """
    
    ```

    

- 切片结合索引

  - 示例一

    ```python
    import numpy as np
    
    a = np.array([0, 1, 2, 2, 1, 0, 1, 1, 2, 1, 0,1])
    x = np.random.randint(1, 20, (5, 12))
    
    print(x)
    print(x[:, a == 1])
    print(a==1)
    
    """
    输出：
    [[14 15  1 10  6 19  1  7 10  3  8  1]
     [ 3 14  4 10  9 12  5 18  5 10 15  3]
     [19  2 10  1  3 17 19  3 12  2  8 14]
     [17  7 14  4 10 19 19  8 18  2  1  4]
     [ 2 12 16 11 18 19 19 13 16 18  9 13]]
     
     [[15  6  1  7  3  1]
     [14  9  5 18 10  3]
     [ 2  3 19  3  2 14]
     [ 7 10 19  8  2  4]
     [12 18 19 13 18 13]]
     
     [False  True False False  True False  True  True False  True False  True]
    """
    
    """
    操作的本意是将a中等于1的那几列在矩阵x取出。
    """
    ```

  - 示例二

    ```python
    x = np.random.randint(1, 20, (5, 12))
    print(x)
    print(x[:, [1, 3, 5, 6, 8]])
    
    """
    [[10 10  5  8  1 13 17 13  1  1  3 16]
     [19 16  6 14 12  7 12  5  5 19  9  8]
     [16 17 10 11  2 19  7 19 10 18 18  2]
     [19  1  6 19  5 11  1  5  1  2  8  7]
     [ 7 13  1 18 15  2  8  4  9 18  2 11]]
     
    [[10  8 13 17  1]
     [16 14  7 12  5]
     [17 11 19  7 10]
     [ 1 19 11  1  1]
     [13 18  2  8  9]]
    """
    ```

    

  - 

```python
> device = torch.device('cuda:0')
> device
device(type='cuda', index=0)
```



#### torch 矩阵乘法

- torch.mul 用法与*乘法相同，也是**element-wise**的乘法，也是支持broadcast的。
- torch.mm 数学里的矩阵乘法，要求两个Tensor的维度满足矩阵乘法的要求.
- torch.matmul  torch.mm的broadcast版本.
- torch.bmm



- 